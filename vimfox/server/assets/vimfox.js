// Generated by CoffeeScript 1.6.3
/* vimfox.js ~ initiates websocket / reload script*/

var namespace,
  __slice = [].slice;

namespace = function(target, name, block) {
  var item, top, _i, _len, _ref, _ref1;
  if (arguments.length < 3) {
    _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
  }
  top = target;
  _ref1 = name.split('.');
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    item = _ref1[_i];
    target = target[item] || (target[item] = {});
  }
  return block(target, top);
};

window.onload = function() {
  return vimfox.initVimfox();
};

namespace('vimfox', function(exports) {
  exports._initLog = [];
  exports.log = function(m) {
    if (vimfox.settings == null) {
      return vimfox._initLog.push(m);
    } else if (vimfox.settings.debug_mode) {
      return console.log("vimfox_debug >> " + m);
    }
  };
  exports.initVimfox = function() {
    var link, script, _i, _j, _len, _len1, _ref, _ref1, _results;
    vimfox.log("Initiating vimfox.js.");
    vimfox.status = new vimfox.Status();
    _ref = document.getElementsByTagName('script');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      script = _ref[_i];
      if (script.src.match('vimfox.js')) {
        exports.HOST = script.src.replace('/vimfox/vimfox.js', '');
        vimfox.log("Retrieved vimfox server HOST: " + vimfox.HOST + ".");
        break;
      }
    }
    if (typeof io !== "undefined" && io !== null) {
      vimfox.log("'io' found in namespace. Skipping js injection.");
      vimfox.createSockets();
    } else {
      vimfox.log("'io' not found in namespace. Injecting 'socket.io.js'.");
      document.body.appendChild(vimfox.injectJS("" + vimfox.HOST + "/vimfox/socket.io.min.js", function() {
        return vimfox.createSockets();
      }));
    }
    vimfox.cssFiles = {};
    vimfox.log("Searching for reloadable stylesheets.");
    _ref1 = document.getElementsByTagName('link');
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      link = _ref1[_j];
      _results.push(vimfox.cssFiles[link.href.match(/[^/]+$/)[0]] = {
        link: link,
        reload: function(delay) {
          var _this = this;
          if (delay == null) {
            delay = 0;
          }
          return setTimeout((function() {
            return _this.link.href = _this.link.href.replace(/\?[0-9]+$/, "") + ("?" + (+(new Date)));
          }), delay * 1000);
        }
      });
    }
    return _results;
  };
  exports.createSockets = function() {
    var socket;
    vimfox.log("Connecting to vimfox socket server.");
    socket = io.connect("" + vimfox.HOST + "/ws");
    socket.on('error', function(e) {
      vimfox.log("Connection error!");
      return vimfox.status.update_status(2);
    });
    socket.on('disconnect', function() {
      vimfox.log("Connection lost!");
      return vimfox.status.update_status(2);
    });
    vimfox.log("Requesting vimfox settings.");
    socket.emit("settings");
    socket.on("settings", function(data) {
      var m, _i, _len, _ref, _results;
      vimfox.log("Connected. Parsing settings.");
      vimfox.status.update_status(0);
      vimfox.settings = {
        debug_mode: data.debug_mode,
        hide_status: data.hide_status
      };
      if (vimfox.settings.hide_status) {
        vimfox.status.kill_me();
      }
      if (vimfox.settings.debug_mode === true) {
        _ref = vimfox._initLog;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          _results.push(vimfox.log(m));
        }
        return _results;
      }
    });
    socket.on('reload_file', function(data) {
      vimfox.log("'reload_file' socket activated: file: " + data.fname + ".");
      socket.emit("busy");
      if (!vimfox.cssFiles[data.fname]) {
        vimfox.status.update_status(1, "could not find " + data.fname + " in DOM.");
      } else {
        vimfox.cssFiles[data.fname].reload(data.delay);
      }
      return socket.emit("ready");
    });
    return socket.on('reload_page', function(data) {
      vimfox.log("'reload_page' socket activated.");
      return setTimeout((function() {
        return location.reload();
      }), data.delay * 1000);
    });
  };
  exports.injectJS = function(src, onload) {
    var s;
    s = document.createElement('script');
    s.type = 'text/javascript';
    s.onload = onload;
    s.src = src;
    return s;
  };
  return exports.Status = (function() {
    function Status() {
      var d;
      d = document.createElement('div');
      d.id = "vimfox_status";
      document.body.appendChild(d);
      this.me = document.getElementById('vimfox_status');
      this.update_status(1);
    }

    Status.prototype.update_status = function(status_code, tooltip) {
      var k, status_color, v, _ref;
      if (status_code == null) {
        status_code = 0;
      }
      if (tooltip == null) {
        tooltip = "";
      }
      status_color = ['green', 'orange', 'red'][status_code];
      _ref = {
        position: 'absolute',
        height: '10px',
        width: '10px',
        margin: '10px',
        top: '0',
        right: '0',
        backgroundColor: status_color
      };
      for (k in _ref) {
        v = _ref[k];
        this.me.style[k] = v;
      }
      return this.me.title = tooltip;
    };

    Status.prototype.kill_me = function() {
      return document.body.removeChild(this.me);
    };

    return Status;

  })();
});
